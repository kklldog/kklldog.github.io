
好久没写文章了，有些同学问我公众号是不是废了？其实并没有。其实想写的东西很多很多，主要是最近公司比较忙，以及一些其他个人原因没有时间来更新文章。这几天抽空写了一点点东西，证明公众号还活着。   
长久以来的认知，对于托管代码 .NET / JAVA ，都是需要在服务器上安装 SDK 或者运行时的。比如 .NET Framework 4.XX ，JDK/JRE.XX 等。其实从 .NET Core 2.1 开始我们的 .NET 程序可以独立打包成可以执行文件，在服务器上根本不需要安装任何运行时相关的东西就可以运行。这个发布模式在某些情况下可以大大提高部署的效率。以下简单介绍一下。
## “独立”部署模式
在发布界面部署模式选择“独立”，点击保存之后然后正常发布。等到发布完成之后，查看 publish 目录，可以发现里面生成了一大堆文件，数量有上百个。这里其实就包含了 runtime 相关的文件。   
![](https://static.xbaby.xyz/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220802100540.png)   
我们把这堆文件全部复制到某个未安装过 .NET SDK 或者 runtime 的 windows 服务器上，找到 SelfContainedTest.exe 文件，双击运行。如果一切顺利，会启动一个控制台。   
![](https://static.xbaby.xyz/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220802101000.png)
   
![](https://static.xbaby.xyz/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220802101033.png)   
访问一下服务器的 5000 口，看到测试数据被成功的输出了，证明我们的 .NET 程序可以正常运行了 。   
![](https://static.xbaby.xyz/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220802101139.png)   
## 单文件
上面的操作我们已经可以不安装运行时在服务器上运行 .NET 程序了。但是那么多文件看着不太优雅，下面让我们的 .NET 程序打包成一个文件。   
打开发布设置界面，勾上“生成单个文件”   
![](https://static.xbaby.xyz/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220802103312.png)   
点击保存，发布之后，在 publish 目录可以看到只剩下 6 个文件了。排除配置文件，pdb 文件等，其实真正的程序只是 SelfContainedTest.exe 文件，所以称之为单文件。双击这个文件我们的程序就可以正常的运行了。   
![](https://static.xbaby.xyz/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220802102933.png)

## 裁剪
以上我们已经把程序从多个文件打包成一个文件了。这个文件我们可以看到有 70 M ，对于我们一个简单的演示程序来说 70M 也挺大了。那么有什么办法来缩小我们的可以执行文件吗？   
其实我们只要在发布配置上打开裁剪功能，就可以缩小我们的程序。   
![](https://static.xbaby.xyz/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220802103326.png)    
在发布配置界面勾上“裁剪未使用的代码”，点击保存，发布之后，在 publish 文件夹下面生成的 SelfContainedTest.exe 文件缩小到了 30M 左右。    
![](https://static.xbaby.xyz/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220802103458.png)    
### 裁剪的注意点
这里大概说一下裁剪的原理。当我们使用裁剪功能的时候，发布程序会开始分析我们的代码，哪些类被使用，哪些类没有使用，没有使用的类就会被删除掉，使用这样的原理来减小发布后程序集的大小。    
但是以上方法显然会有一个问题，那就是无法识别动态性很强的代码，比如反射实现的某些功能。比如以下代码：
```
string s = Console.ReadLine();
Type type = Type.GetType(s);
foreach (var m in type.GetMethods())
{
    Console.WriteLine(m.Name);
}
```
显然以上代码静态分析没办法知道程序最终需要使用那些类，因为目标类是通过 Console.ReadLine 方法输入进去的。在程序没有执行的时候谁也不知道哪些类会被使用。

## 在 IIS 上运行
上面我们演示程序运行的时候是寄宿在控制台上的，这样的话很容易被人误关闭。其实单文件发布的程序照样可以使用 IIS 来托管。   
按照正常的 IIS 发布网站的流程配置之后，把应用程序池设置为 “无托管代码” 访问对应的端口程序就可以正常运行了。   
   
![](https://static.xbaby.xyz/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220802104105.png)
## 在 linux 上运行

以上我们都是在 windows 上测试，现在让我们试一下在 linux 上运行它。  
在 linux 上运行的话，需要在发布配置界面修改“目标运行时”为 linux-64 。    
![](https://static.xbaby.xyz/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220802104313.png)
发布成功后把生成的文件复制到 linux 服务器上。cd 到目录，运行以下代码。
```
chmod +x SelfContainedTest
./SelfContainedTest
```
很不幸，我们的程序没有按计划运行起来。   
![](https://static.xbaby.xyz/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220802105529.png)   
通过搜索后发现，需要设置一个环境变量。修改运行的代码:
```
export DOTNET_SYSTEM_GLOBALIZATION_INVARIANT=1
./SelfContainedTest
```
运行完之后我们的程序应该会顺利的启动。访问一下对应的 http 接口，可以看到正确的输出了。
    
![](https://static.xbaby.xyz/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220802105750.png)
   
## 总结
通过以上演示，我们根本没必要在服务器（windows/linux）上安装任何 SDK 或者运行时就可以完整的运行我们的 .NET 程序。而且通过裁剪之后我们的程序的大小也缩小到了一个很小的范围。以上功能对于互联网行业来说可能没什么必要，毕竟大家走的都是容器化部署，服务器上本来就不需要安装运行时。但是对于一些传统行业，比如医院这样的环境，还有很多需要在服务器上人肉部署的场景。在这些场景之下就非常有意义了，可以大大的体高部署的效率。毕竟不是谁都可以很快的在服务器上安装好运行时，特别是 linux 服务器。   
其实不安装运行时来运行程序还有一个办法，那就是使用 AOT 发布，这个我们下次再讲。

## 关注我的公众号一起玩转技术   

![](https://static.xbaby.xyz/qrcode.jpg)